/*
 * 4ALLPORTAL REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1-SNAPSHOT
 * Contact: support@4allportal.net
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Serialize, Deserialize};

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`modules_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_files_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdFilesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_files_filekey_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdFilesFilekeyDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_files_filekey_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdFilesFilekeyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_files_filekey_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdFilesFilekeyPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdFilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_configs_snapin_objects_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleConfigsSnapinObjectsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_layouts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleLayoutsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_layouts_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleLayoutsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_renderers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleRenderersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_renderers_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleRenderersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modules_module_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModulesModuleStatsGetError {
    UnknownValue(serde_json::Value),
}


pub async fn modules_get(configuration: &configuration::Configuration, groups: Option<Vec<String>>, modules: Option<Vec<String>>) -> Result<Vec<crate::models::ModuleConfig>, Error<ModulesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = groups {
        local_var_req_builder = local_var_req_builder.query(&[("groups", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = modules {
        local_var_req_builder = local_var_req_builder.query(&[("modules", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_delete(configuration: &configuration::Configuration, module: &str, snapin: &str, names: Option<Vec<String>>) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = names {
        local_var_req_builder = local_var_req_builder.query(&[("names", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_get(configuration: &configuration::Configuration, module: &str, snapin: &str) -> Result<crate::models::AdminConfigResult, Error<ModulesModuleConfigsSnapinObjectsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_delete(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_files_delete(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsIdFilesDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}/files", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdFilesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_files_filekey_delete(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str, filekey: &str) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsIdFilesFilekeyDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}/files/{filekey}", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id), filekey=crate::apis::urlencode(filekey));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdFilesFilekeyDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_files_filekey_get(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str, filekey: &str) -> Result<crate::models::Resource, Error<ModulesModuleConfigsSnapinObjectsIdFilesFilekeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}/files/{filekey}", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id), filekey=crate::apis::urlencode(filekey));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdFilesFilekeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_files_filekey_put(configuration: &configuration::Configuration, filename: &str, module: &str, snapin: &str, id: &str, filekey: &str, resource: Option<crate::models::Resource>) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsIdFilesFilekeyPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}/files/{filekey}", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id), filekey=crate::apis::urlencode(filekey));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("filename", &filename.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&resource);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdFilesFilekeyPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_files_get(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str) -> Result<Vec<crate::models::SnapInFiles>, Error<ModulesModuleConfigsSnapinObjectsIdFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}/files", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_get(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str) -> Result<crate::models::AdminConfigResult, Error<ModulesModuleConfigsSnapinObjectsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_id_put(configuration: &configuration::Configuration, module: &str, snapin: &str, id: &str, body: Option<serde_json::Value>) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects/{id}", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_configs_snapin_objects_put(configuration: &configuration::Configuration, module: &str, snapin: &str, body: Option<serde_json::Value>) -> Result<(), Error<ModulesModuleConfigsSnapinObjectsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/configs/{snapin}/objects", local_var_configuration.base_path, module=crate::apis::urlencode(module), snapin=crate::apis::urlencode(snapin));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ModulesModuleConfigsSnapinObjectsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_get(configuration: &configuration::Configuration, module: &str, groups: Option<Vec<String>>) -> Result<crate::models::ModuleConfig, Error<ModulesModuleGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}", local_var_configuration.base_path, module=crate::apis::urlencode(module));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = groups {
        local_var_req_builder = local_var_req_builder.query(&[("groups", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_layouts_get(configuration: &configuration::Configuration, ids: Vec<String>, object_type: &str, module: &str) -> Result<::std::collections::HashMap<String, crate::models::LayoutEntry>, Error<ModulesModuleLayoutsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/layouts", local_var_configuration.base_path, module=crate::apis::urlencode(module));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ids", &ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("objectType", &object_type.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleLayoutsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_layouts_id_get(configuration: &configuration::Configuration, object_type: &str, module: &str, id: &str) -> Result<crate::models::LayoutEntry, Error<ModulesModuleLayoutsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/layouts/{id}", local_var_configuration.base_path, module=crate::apis::urlencode(module), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("objectType", &object_type.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleLayoutsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_renderers_get(configuration: &configuration::Configuration, module: &str, ids: Option<Vec<String>>, object_type: Option<&str>) -> Result<::std::collections::HashMap<String, crate::models::ObjectRendererBase>, Error<ModulesModuleRenderersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/renderers", local_var_configuration.base_path, module=crate::apis::urlencode(module));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ids {
        local_var_req_builder = local_var_req_builder.query(&[("ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = object_type {
        local_var_req_builder = local_var_req_builder.query(&[("objectType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleRenderersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_renderers_id_get(configuration: &configuration::Configuration, module: &str, id: &str, object_type: Option<&str>) -> Result<crate::models::ObjectRendererBase, Error<ModulesModuleRenderersIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/renderers/{id}", local_var_configuration.base_path, module=crate::apis::urlencode(module), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = object_type {
        local_var_req_builder = local_var_req_builder.query(&[("objectType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleRenderersIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn modules_module_stats_get(configuration: &configuration::Configuration, module: &str) -> Result<crate::models::ModuleStatsResult, Error<ModulesModuleStatsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/modules/{module}/stats", local_var_configuration.base_path, module=crate::apis::urlencode(module));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModulesModuleStatsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

